# https://www.acmicpc.net/problem/2178

# N×M크기의 배열로 표현되는 미로가 있다.

# 1	0	1	1	1	1
# 1	0	1	0	1	0
# 1	0	1	0	1	1
# 1	1	1	0	1	1
# 미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.

# 위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.

# 첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.

# 첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.

# 4 6
# 101111
# 101010
# 101011
# 111011

# 15

# 4 6
# 110110
# 110110
# 111111
# 111101

# 9

# 2 25
# 1011101110111011101110111
# 1110111011101110111011101

# 38

# 7 7
# 1011111
# 1110001
# 1000001
# 1000001
# 1000001
# 1000001
# 1111111

# 13
# https://www.acmicpc.net/problem/2178

# N×M크기의 배열로 표현되는 미로가 있다.

# 1	0	1	1	1	1
# 1	0	1	0	1	0
# 1	0	1	0	1	1
# 1	1	1	0	1	1
# 미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.

# 위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.

# 첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.

# 첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.

# 4 6
# 101111
# 101010
# 101011
# 111011

# 15

# 4 6
# 110110
# 110110
# 111111
# 111101

# 9

# 2 25
# 1011101110111011101110111
# 1110111011101110111011101

# 38

# 7 7
# 1011111
# 1110001
# 1000001
# 1000001
# 1000001
# 1000001
# 1111111

# 13

# bfs는 시작점에서 먼 정점일 경우 큐에 늦게 도착하기 때문에
# 항상 가까운 경로를 먼저 방문하게 됨
# 최적의 경로만을 다니므로 dp 값 갱신을 생각하지 않아도 됨

from collections import deque

if __name__ == "__main__":
  def solution():
    n, m = map(int, input().split())
    maze = []
    visited = []
    dp = [[0 for _ in range(m)] for _ in range(n)]
    dp[0][0] = 1

    for _ in range(n):
      maze.append(list(map(int, input())))

    def bfs(i, j):
      queue = deque([[i, j]])

      while queue:
        [i, j] = queue.popleft()
        visited.append([i, j])

        # 위
        if i > 0 and maze[i - 1][j] == 1 and [i - 1, j] not in visited and [i - 1, j] not in queue:
          queue.append([i - 1, j])
          dp[i - 1][j] = dp[i][j] + 1 # 이전 위치 + 1

        # 아래
        if i < n - 1 and maze[i + 1][j] == 1 and [i + 1, j] not in visited and [i + 1, j] not in queue:
          queue.append([i + 1, j])
          dp[i + 1][j] = dp[i][j] + 1 # 이전 위치 + 1

        # 왼쪽
        if j > 0 and maze[i][j - 1] == 1 and [i, j - 1] not in visited and [i, j - 1] not in queue:
          queue.append([i, j - 1])
          dp[i][j - 1] = dp[i][j] + 1 # 이전 위치 + 1

        # 오른쪽
        if j < m - 1 and maze[i][j + 1] == 1 and [i, j + 1] not in visited and [i, j + 1] not in queue:
          queue.append([i, j + 1])
          dp[i][j + 1] = dp[i][j] + 1 # 이전 위치 + 1
    
    bfs(0, 0)
    print(dp)
    return dp[n - 1][m - 1]
  print(solution())

#  1,  0,  9, 10, 11, 12
#  2,  0,  8,  0, 12,  0
#  3,  0,  7,  0, 13, 14
#  4,  5,  6,  0, 14, 15

#  1,  2,  0,  8,  9,  0
#  2,  3,  0,  7,  8,  0
#  3,  4,  5,  6,  7,  8
#  4,  5,  6,  7,  0,  9